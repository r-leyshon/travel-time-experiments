[
  {
    "objectID": "supermarket-accessibility-cardiff.html",
    "href": "supermarket-accessibility-cardiff.html",
    "title": "Analyse Supermaket Accessibility in Cardiff LAD",
    "section": "",
    "text": "from datetime import datetime, timedelta\nimport os\nimport subprocess\n\nimport contextily as ctx\nimport folium\nimport geopandas as gpd\nfrom haversine import haversine, Unit\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom pyprojroot import here\nimport requests\nimport r5py\nfrom shapely.geometry import LineString"
  },
  {
    "objectID": "supermarket-accessibility-cardiff.html#load-supermarket-points",
    "href": "supermarket-accessibility-cardiff.html#load-supermarket-points",
    "title": "Analyse Supermaket Accessibility in Cardiff LAD",
    "section": "Load Supermarket Points",
    "text": "Load Supermarket Points\n\nsupermarkets = pd.read_csv(here(\"data/external/features/geolytix_cut.csv\"))\nsuper_gdf = gpd.GeoDataFrame(\n    supermarkets,\n    geometry=gpd.points_from_xy(\n        supermarkets[\"long_wgs\"], supermarkets[\"lat_wgs\"]\n        ),\n    crs=\"EPSG:4326\")\nsuper_gdf[\"id\"] = list(range(0, len(super_gdf)))# unique ID column for routing\nsuper_gdf.explore()\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "supermarket-accessibility-cardiff.html#ingest-cardiff-boundary",
    "href": "supermarket-accessibility-cardiff.html#ingest-cardiff-boundary",
    "title": "Analyse Supermaket Accessibility in Cardiff LAD",
    "section": "Ingest Cardiff Boundary",
    "text": "Ingest Cardiff Boundary\n2023 boundary, full resolution clipped to coastline.\n\nENDPOINT = \"https://services1.arcgis.com/ESMARspQHYMw9BZ9/arcgis/rest/services/Local_Authority_Districts_December_2023_Boundaries_UK_BFC/FeatureServer/0/query\"\nPARAMS = {\n    \"where\": \"LAD23CD = 'W06000015'\",\n    \"f\": \"geoJSON\", \n    \"outFields\": \"*\",\n    \"outSR\": 27700,\n}\n\n\ndef get_ons_geo_data(endpoint:str, params:dict) -&gt; gpd.GeoDataFrame:\n    \"Cast json response to gdf\"\n    resp = requests.get(endpoint, params=params)\n    if resp.ok:\n        content = resp.json()\n    else:\n        raise requests.RequestException(\n            f\"HTTP {resp.status_code} : {resp.reason}\")\n            \n    gdf = gpd.GeoDataFrame.from_features(\n        content[\"features\"], crs=content[\"crs\"][\"properties\"][\"name\"])\n\n    return content, gdf\n\n\ncontent, poly = get_ons_geo_data(ENDPOINT, PARAMS)\npoly.head()\n\n\n\n\n\n\n\n\n\ngeometry\nFID\nLAD23CD\nLAD23NM\nLAD23NMW\nBNG_E\nBNG_N\nLONG\nLAT\nShape__Area\nShape__Length\nGlobalID\n\n\n\n\n0\nMULTIPOLYGON (((322081.699 165165.901, 322082....\n353\nW06000015\nCardiff\nCaerdydd\n315272\n178887\n-3.22209\n51.50254\n1.423040e+08\n79590.02316\n8493a146-4d0f-4048-9c96-4a15a3257573\n\n\n\n\n\n\n\n\n\n# buffer by a km to avoid edge effects\nbuffered_poly = gpd.GeoDataFrame(\n    {\"geometry\": poly.buffer(5000)},\n    crs=content[\"crs\"][\"properties\"][\"name\"])\nbuffered_poly.to_crs(4326, inplace=True)\npoly.to_crs(4326, inplace=True)\nproximal_supers = super_gdf.sjoin(buffered_poly)\n\n\nfig, ax = plt.subplots()\npoly.plot(ax=ax, facecolor=\"red\", alpha=0.4)\nbuffered_poly.plot(ax=ax, facecolor=\"blue\", alpha=0.2)\nproximal_supers.plot(ax=ax, color=\"blue\", markersize=3)\nctx.add_basemap(\n    ax,\n    crs=proximal_supers.crs.to_string(), source=ctx.providers.CartoDB.Voyager\n)\nplt.title(f\"{len(proximal_supers)} Supermarkets Within 5 km Buffered Cardiff LAD extent\")\nplt.tight_layout()\nplt.savefig(\"outputs/cardiff-supermarkets/cardiff-supermarkets-5km-buffer.png\", dpi=400)"
  },
  {
    "objectID": "supermarket-accessibility-cardiff.html#by-output-area-population-weighted-centroid",
    "href": "supermarket-accessibility-cardiff.html#by-output-area-population-weighted-centroid",
    "title": "Analyse Supermaket Accessibility in Cardiff LAD",
    "section": "By Output Area Population-Weighted Centroid",
    "text": "By Output Area Population-Weighted Centroid\nOutput Areas (December 2021) PWC (V3)\n\nENDPOINT = \"https://services1.arcgis.com/ESMARspQHYMw9BZ9/arcgis/rest/services/Output_Areas_2021_PWC_V3/FeatureServer/0/query\"\nPARAMS[\"where\"] = \"OA21CD like 'W%'\"\nPARAMS[\"resultOffset\"] = 0\nPARAMS[\"outSR\"] = 4326\n\n\ndef get_ons_geo_paginated(endpoint:str, params:dict) -&gt; gpd.GeoDataFrame:\n    content, gdf = get_ons_geo_data(ENDPOINT, PARAMS)\n    more_pages = content[\"properties\"][\"exceededTransferLimit\"]\n    offset = len(gdf) # number of records to offset by\n    all_gdfs = gdf # append gdfs here\n    while more_pages:\n        params[\"resultOffset\"] += offset # increment the records\n        content, gdf = get_ons_geo_data(endpoint, params)\n        all_gdfs = pd.concat([all_gdfs, gdf])\n        try:\n            more_pages = content[\"properties\"][\"exceededTransferLimit\"]\n        except KeyError:\n            # rather than exceededTransferLimit = False, it disappears...\n            more_pages = False\n    all_gdfs = all_gdfs.reset_index(drop=True)\n    return all_gdfs\n\n\n# PARAMS[\"returnCountOnly\"] = True\n# 10275 Welsh centroids\ncentroids = get_ons_geo_paginated(ENDPOINT, PARAMS)\nlen(centroids)\n\n10275\n\n\n\ncardiff_centroids = centroids.sjoin(poly)\nfig, ax = plt.subplots()\npoly.plot(ax=ax, facecolor=\"red\", alpha=0.4)\nbuffered_poly.plot(ax=ax, facecolor=\"blue\", alpha=0.2)\nproximal_supers.plot(ax=ax, color=\"blue\", markersize=3)\nctx.add_basemap(\n    ax,\n    crs=proximal_supers.crs.to_string(), source=ctx.providers.CartoDB.Voyager\n)\nplt.title(f\"{len(cardiff_centroids)} Centroids Within Cardiff LAD extent\")\ncardiff_centroids.plot(ax=ax, color=\"green\", markersize=3, alpha=0.2)\nplt.tight_layout()\nplt.savefig(\"outputs/cardiff-supermarkets/cardiff-centroids-supermarkets-5km-buffer.png\", dpi=400)\n\n\n\n\n\n\n\n\n\n# get osm data\nosm_pth = here(\"data/external/osm/wales-latest.osm.pbf\")\nif not os.path.exists(osm_pth):\n  subprocess.run(\n      [\n        \"curl\",\n        \"https://download.geofabrik.de/europe/united-kingdom/wales-latest.osm.pbf\",\n        \"-o\",\n        osm_pth,])\n\nHere is where the Java dependency kicks in…\n\ntransport_network = r5py.TransportNetwork(osm_pth)\n# adjust all centroids to transport network\ncardiff_centroids[\"snapped_geometry\"] = transport_network.snap_to_network(\n    cardiff_centroids[\"geometry\"],\n    radius=100,\n    street_mode=r5py.TransportMode.WALK,\n)\n\n\n# snap distance summaries\n# reverse the lonlat to latlon\ncardiff_centroids[\"snap_dist_m\"] = cardiff_centroids.apply(\n    lambda row:haversine(\n        (row[\"geometry\"].y, row[\"geometry\"].x),\n        (row[\"snapped_geometry\"].y, row[\"snapped_geometry\"].x),\n        unit=Unit.METERS), axis=1)\n\ncardiff_centroids[\"snap_dist_m\"].plot.hist(\n    bins=50,\n    title=\"Distribution of coordinate snap distance in point plane (m)\"\n    )\nplt.show()\n\n\n\n\n\n\n\n\n\nlargest_snaps = cardiff_centroids.copy(deep=True)\n# retrieve the top n rows where coordinates adjusted by the greatest dist.\nn = 20\nlargest_snaps = largest_snaps.sort_values(\n    by=\"snap_dist_m\", ascending=False).head(n)\n# create the LineString geometry\nlargest_snaps[\"lines\"] = largest_snaps.apply(\n    lambda row: LineString([row[\"geometry\"], row[\"snapped_geometry\"]]),\n    axis=1\n)\nz_start = 11\n# original geometry layer\nimap = largest_snaps.explore(\n    marker_type=\"marker\",\n    marker_kwds={\n        \"icon\": folium.map.Icon(color=\"red\", icon=\"ban\", prefix=\"fa\"),\n    },\n    map_kwds={\n        \"center\": {\"lat\": 51.478, \"lng\": -3.165}\n    },\n    zoom_start=z_start,\n)\n# snapped geometry layer\nimap = largest_snaps.set_geometry(\"snapped_geometry\").explore(\n    m=imap,\n    marker_type=\"marker\",\n    marker_kwds={\n        \"icon\": folium.map.Icon(color=\"green\", icon=\"person-walking\", prefix=\"fa\"),\n    }\n)\n# line geometry layer\nimap = largest_snaps.set_geometry(\"lines\").explore(\n    m=imap,\n    zoom_start=z_start\n)\nimap\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n# drop the original centroids in favour of snapped geoms\ncardiff_centroids.drop(\n    columns=[\"geometry\", \"snap_dist_m\"], axis=1, inplace=True)\ncardiff_centroids.rename(columns={\n    \"snapped_geometry\": \"geometry\",\n    \"OA21CD\": \"id\",\n    }, inplace=True)\ncardiff_centroids.set_geometry(\"geometry\", inplace=True)\n\n\ndept_time = datetime.now().replace(hour=8, minute=0, second=0, microsecond=0)\n\ntravel_time_matrix = r5py.TravelTimeMatrixComputer(\n    transport_network,\n    origins=cardiff_centroids,\n    destinations=proximal_supers,\n    transport_modes=[r5py.TransportMode.WALK, r5py.TransportMode.CAR],\n    departure=dept_time,\n    departure_time_window=timedelta(minutes=60), # every minute until 9am\n    snap_to_network=False,\n    max_time=timedelta(minutes=60),\n    speed_walking = 4.8, # default is 3.6km/h\n\n).compute_travel_times()\n\ntravel_time_matrix.dropna().head()\n\n\n\n\n\n\n\n\n\nfrom_id\nto_id\ntravel_time\n\n\n\n\n0\nW00010120\n86\n9\n\n\n1\nW00010120\n273\n30\n\n\n2\nW00010120\n455\n16\n\n\n3\nW00010120\n456\n12\n\n\n4\nW00010120\n643\n30\n\n\n\n\n\n\n\n\n\nEngineer Travel Time Matrix\nCalculate median travel time across each supermarket. This gives us a median travel time from all centroids to all reachable supermarkets. Also need to merge to geometries to add spatial context. Going with 2021 boundaries generalised to 20m resolution as just for mapping a centroid value.\nOther features of interest may be:\n\nnumber of reachable supermarkets\nan ‘effective population served within 1 hour by car and by foot’.\nan accessibility statistic such as the ratio of reachable / proximal supermarkets. eg the number of supermarkets you can reach through the transport network as a proportion of the number within a crow’s flight radius.\n\n\nmed_tts = travel_time_matrix.drop(\"to_id\", axis=1).groupby(\"from_id\").median()\nENDPOINT = \"https://services1.arcgis.com/ESMARspQHYMw9BZ9/arcgis/rest/services/Output_Areas_2021_EW_BGC_V2/FeatureServer/0/query\"\nPARAMS[\"where\"] = \"OA21CD like 'W%'\"\nPARAMS[\"resultOffset\"] = 0\n\noa_polys = get_ons_geo_paginated(ENDPOINT, PARAMS)\nlen(oa_polys)\n\n10275\n\n\n\nmedian_tt_oa = med_tts.join(oa_polys.set_index(\"OA21CD\"))\nmedian_tt_oa = gpd.GeoDataFrame(median_tt_oa, crs=4326)\nmedian_tt_oa.head()\n\n\n\n\n\n\n\n\n\ntravel_time\ngeometry\nFID\nLSOA21CD\nLSOA21NM\nLSOA21NMW\nBNG_E\nBNG_N\nLAT\nLONG\nShape__Area\nShape__Length\nGlobalID\n\n\nfrom_id\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nW00008779\n12.5\nPOLYGON ((-3.15371 51.48625, -3.15409 51.48610...\n187079\nW01001694\nCardiff 036A\nCaerdydd 036A\n319717\n177053\n51.48670\n-3.15765\n37192.300659\n1323.933139\n22955f09-cd77-4133-b0c6-5d3d54a1564d\n\n\nW00008780\n12.0\nPOLYGON ((-3.15290 51.48853, -3.15203 51.48723...\n187080\nW01001697\nCardiff 036D\nCaerdydd 036D\n320018\n177178\n51.48787\n-3.15334\n20110.197174\n656.083765\nede6239d-fa9e-4fa2-95e4-d2609951f8dd\n\n\nW00008781\n12.0\nPOLYGON ((-3.15856 51.48645, -3.15806 51.48628...\n187081\nW01001694\nCardiff 036A\nCaerdydd 036A\n319566\n177006\n51.48626\n-3.15981\n42158.049187\n1093.054113\na45f08c9-683b-41fa-aebe-8c401cec73d8\n\n\nW00008782\n12.0\nPOLYGON ((-3.15490 51.48587, -3.15718 51.48494...\n187082\nW01001694\nCardiff 036A\nCaerdydd 036A\n319789\n176962\n51.48589\n-3.15659\n25546.097813\n655.481197\n0293396c-8ba5-4782-bf24-216461db1709\n\n\nW00008784\n13.0\nPOLYGON ((-3.15371 51.48625, -3.15447 51.48498...\n187083\nW01001694\nCardiff 036A\nCaerdydd 036A\n319925\n176862\n51.48502\n-3.15461\n34684.802540\n1455.580623\n888a5b61-4a7b-466d-ae54-fc9ff0685663\n\n\n\n\n\n\n\n\n\nimap = median_tt_oa.explore(\"travel_time\", cmap=\"viridis_r\", tiles=\"CartoDB positron\")\nimap = proximal_supers.explore(\n    m=imap,\n    marker_type=\"marker\",\n    marker_kwds={\n        \"icon\": folium.map.Icon(color=\"red\", icon=\"cart-shopping\", prefix=\"fa\"),\n    }\n)\nimap.save(\"outputs/cardiff-supermarkets/median_tt_to_supermarkets_5km_buffer.html\")\nimap\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nThis is one option for calculation of origins. Population-weighted centroids are ok, but I would advise taking a gridded approach, using Global Human Settlement Layer or equivalent. Finer spatial resolution, down to 10m grids if you really wanted that. There are some caveats with this data that I can point out if helpful."
  },
  {
    "objectID": "gp-surgeries-wolthamstow.html",
    "href": "gp-surgeries-wolthamstow.html",
    "title": "Analyse GP Surgery Accessibility in Wolthamstow",
    "section": "",
    "text": "Click to show code\nfrom datetime import datetime\nimport glob\nimport os\nfrom pathlib import Path\nimport subprocess\nfrom time import sleep\nimport toml\n\nimport geopandas as gpd\nfrom geopy.geocoders import Nominatim\nfrom geopy.exc import GeocoderUnavailable\nfrom geopy import point\nimport pandas as pd\nfrom pyprojroot import here\nfrom shapely import geometry\n\nfrom transport_performance.osm.osm_utils import filter_osm\n\n# get private user agent\nUSER_AGENT = toml.load(here(\".secrets.toml\"))[\"nominatim\"][\"USER_AGENT\"]\n\n\n\nIngest London OSM.\n\nLondon OSM doesn’t include Loughton & Cheshunt. To avoid edge effects, ingest England OSM latest & filter to custom bounding box.\n\n\nClick to show code\nosm_pth = here(\"data/external/osm/england-latest-osm.pbf\")\nif not os.path.exists(osm_pth):\n    subprocess.run(\n        [\n            \"curl\",\n            \"https://download.geofabrik.de/europe/united-kingdom/england-latest.osm.pbf\", \"-o\",\n            osm_pth\n            ])\n\n\n\nClip London OSM to custom BBOX\n\n\n\nClick to show code\nfiltered_osm_pth = here(\"data/external/osm/wolthamstow-aoi-osm.pbf\")\nBBOX = [-0.368022,51.432659,0.296356,51.765395]\nif not os.path.exists(filtered_osm_pth):\n    filter_osm(pbf_pth=osm_pth, out_pth=filtered_osm_pth, bbox=BBOX, tag_filter=False)\n\n\n\nLocate GP surgeries.\n\nFrom NHS Service Search , surgeries within 50 miles serving Hoe Street, Wolthamstow. Postcodes provided and will need to be geocoded. Investigate whether coordinates are available in NHS developer portal, registration required.\n\n\nClick to show code\nsurg_pth = here(\"data/external/features/nhs-surgeries-E17-3AX.csv\")\nif not os.path.exists(surg_pth):\n    subprocess.run([\n        \"curl\",\n        \"https://www.nhs.uk/service-search/other-services/GP/E17-3AX/Export/4/-0.0193444043397903/51.5837821960449/4/0?distance=50&ResultsOnPageValue=10&isNational=0&totalItems=2845&currentPage=1\",\n        \"-o\",\n        surg_pth\n    ])\n\nsurgeries = pd.read_csv(surg_pth)\nsurgeries = surgeries.loc[:, [\"Organisation Name\", \"PostCode\"]]\nsurgeries[\"id\"] = list(range(0, len(surgeries)))\n\n\n\n\nClick to show code\ndef get_surgery_locs_nominatim(\n    df: pd.DataFrame, out_pth: Path, sleep_s:float=2.0, user: str = USER_AGENT\n    ) -&gt; None:\n    \"\"\"Use orgnm and then postcode to attempt geolocating surgeries. \n    \n    Uses Nominatim. Writes to file if error encountered. \n    \"\"\"\n    tmp_df = df.copy(deep=True)\n    # Instantiate a new Nominatim client\n    app = Nominatim(\n        user_agent=\"\")\n    tmp_df[\"lat\"] = 0.0\n    tmp_df[\"lon\"] = 0.0\n    tmp_df[\"geocode_type\"] = \"None\"\n    geocode_type = []\n    for i, row in tmp_df.iterrows():\n        loc = {\"lon\": 0.0, \"lat\": 0.0}\n        geo_type = \"None\"\n        try:\n            loc = app.geocode(\n                query=row[\"Organisation Name\"],\n                country_codes=\"gb\",\n                viewbox=[\n                    point.Point(51.375, -0.509), point.Point(51.868, 0.530)],\n                bounded=True)\n            print(\"Geocode by Org Name success\")\n            sleep(sleep_s)\n            geo_type = \"from_nm\"\n            if not loc:\n                # case where name did not return a location\n                loc = app.geocode(\n                    query=row[\"PostCode\"],\n                    country_codes=\"gb\",\n                    viewbox=[\n                        point.Point(51.375, -0.509), point.Point(51.868, 0.530)\n                        ],\n                    bounded=True)\n                print(\"Geocode by Postcode success\")\n                sleep(sleep_s)\n                geo_type = \"from_pcd\"\n        except GeocoderUnavailable:\n            # nominatim is down\n            print(f\"Breaking on {row['Organisation Name']}\")\n            break\n        finally:\n            # update the geometry column\n            if loc:\n                loc = loc.raw\n                tmp_df.loc[i, [\"lat\"]] = loc[\"lat\"]\n                tmp_df.loc[i, [\"lon\"]] = loc[\"lon\"]\n                tmp_df.loc[i, [\"geocode_type\"]] = geo_type\n            else:\n                break\n    tmp_df.to_csv(out_pth)\n    return tmp_df\n\n\n\n\nClick to show code\n# execute once only as hammers the nominatim service\ngeocoded_surgeries_pth = here(\n    \"data/external/features/geocoded-london-surgeries.csv\")\nif not os.path.exists(geocoded_surgeries_pth):\n    get_surgery_locs_nominatim(df=surgeries, out_pth=cache_pth, sleep_s=2.0)\n\n\nPresent the geocoded surgeries.\n\n\nClick to show code\ngeocd_pth = here(\"data/external/features/\").glob(\"geocode-surgeries-*\")\ngeocd_surgeries = pd.read_csv(list(geocd_pth)[0], index_col=0)\ngeocd_surgeries = geocd_surgeries.dropna()\ngeocd_surgeries = gpd.GeoDataFrame(geocd_surgeries, geometry=gpd.points_from_xy(geocd_surgeries[\"lon\"], geocd_surgeries[\"lat\"]), crs=4326)\ngeocd_surgeries.drop([\"lat\", \"lon\"], axis=1, inplace=True)\ngeocd_surgeries.explore()\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nNote that the accuracy varies dependent upon whether the surgeries were geolocated from the organisation name or the postcode. Most are from postcode. Accuracy of these points will depend on size of postcode.\n\ncode_stats = geocd_surgeries[\"geocode_type\"].describe()\nprint(f\"{round((code_stats.freq / len(geocd_surgeries)) * 100, 1)} % of {len(geocd_surgeries)} surgeries were geocoded by postcode.\")\n\n57.4 % of 535 surgeries were geocoded by postcode.\n\n\n\nget package utilities set up for ons ingest.\nIngest Pop-weighted centroids. Filter pattern for London Boroughs?\nif above not possible, ingest Wolthamstow LAD boundary\nClip centroids to LAD extent\nBuffer LAD by 5km\nClip GP surgeries to 5km buffer\nCompute travel times from centroids to proximal surgeries\nGroup by from_id summarise with median gets median tt to surgeries\nIngest OA boundaries to match centroids\nJoin median tts to OA boundaries by OA21CD - check codes with centroids first\nChloropleth map median_tt, points with surgeries"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Travel Time Experiments",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nAnalyse GP Surgery Accessibility in Wolthamstow\n\n\n\n\n\nLocations Provided by Open Street Map Data\n\n\n\n\n\nFeb 25, 2024\n\n\nRich Leyshon\n\n\n6 min\n\n\n\n\n\n\n\n\n\n\n\n\nAnalyse Supermaket Accessibility in Cardiff LAD\n\n\n\n\n\nDemonstrating a Method for Calculating Indiciative Travel Time Metrics\n\n\n\n\n\nFeb 20, 2024\n\n\nRich Leyshon\n\n\n6 min\n\n\n\n\n\n\nNo matching items"
  }
]