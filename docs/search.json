[
  {
    "objectID": "supermarket-accessibility-cardiff.html",
    "href": "supermarket-accessibility-cardiff.html",
    "title": "Analyse Supermaket Accessibility in Cardiff LAD",
    "section": "",
    "text": "from datetime import datetime, timedelta\nimport os\nimport subprocess\n\nimport contextily as ctx\nimport folium\nimport geopandas as gpd\nfrom haversine import haversine, Unit\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom pyprojroot import here\nimport requests\nimport r5py\nfrom shapely.geometry import LineString"
  },
  {
    "objectID": "supermarket-accessibility-cardiff.html#load-supermarket-points",
    "href": "supermarket-accessibility-cardiff.html#load-supermarket-points",
    "title": "Analyse Supermaket Accessibility in Cardiff LAD",
    "section": "Load Supermarket Points",
    "text": "Load Supermarket Points\n\nsupermarkets = pd.read_csv(here(\"data/external/features/geolytix_cut.csv\"))\nsuper_gdf = gpd.GeoDataFrame(\n    supermarkets,\n    geometry=gpd.points_from_xy(\n        supermarkets[\"long_wgs\"], supermarkets[\"lat_wgs\"]\n        ),\n    crs=\"EPSG:4326\")\nsuper_gdf[\"id\"] = list(range(0, len(super_gdf)))# unique ID column for routing\nsuper_gdf.explore()\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "supermarket-accessibility-cardiff.html#ingest-cardiff-boundary",
    "href": "supermarket-accessibility-cardiff.html#ingest-cardiff-boundary",
    "title": "Analyse Supermaket Accessibility in Cardiff LAD",
    "section": "Ingest Cardiff Boundary",
    "text": "Ingest Cardiff Boundary\n2023 boundary, full resolution clipped to coastline.\n\nENDPOINT = \"https://services1.arcgis.com/ESMARspQHYMw9BZ9/arcgis/rest/services/Local_Authority_Districts_December_2023_Boundaries_UK_BFC/FeatureServer/0/query\"\nPARAMS = {\n    \"where\": \"LAD23CD = 'W06000015'\",\n    \"f\": \"geoJSON\", \n    \"outFields\": \"*\",\n    \"outSR\": 27700,\n}\n\n\ndef get_ons_geo_data(endpoint:str, params:dict) -&gt; gpd.GeoDataFrame:\n    \"Cast json response to gdf\"\n    resp = requests.get(endpoint, params=params)\n    if resp.ok:\n        content = resp.json()\n    else:\n        raise requests.RequestException(\n            f\"HTTP {resp.status_code} : {resp.reason}\")\n            \n    gdf = gpd.GeoDataFrame.from_features(\n        content[\"features\"], crs=content[\"crs\"][\"properties\"][\"name\"])\n\n    return content, gdf\n\n\ncontent, poly = get_ons_geo_data(ENDPOINT, PARAMS)\npoly.head()\n\n\n\n\n\n\n\n\n\ngeometry\nFID\nLAD23CD\nLAD23NM\nLAD23NMW\nBNG_E\nBNG_N\nLONG\nLAT\nShape__Area\nShape__Length\nGlobalID\n\n\n\n\n0\nMULTIPOLYGON (((322081.699 165165.901, 322082....\n353\nW06000015\nCardiff\nCaerdydd\n315272\n178887\n-3.22209\n51.50254\n1.423040e+08\n79590.02316\n8493a146-4d0f-4048-9c96-4a15a3257573\n\n\n\n\n\n\n\n\n\n# buffer by a km to avoid edge effects\nbuffered_poly = gpd.GeoDataFrame(\n    {\"geometry\": poly.buffer(5000)},\n    crs=content[\"crs\"][\"properties\"][\"name\"])\nbuffered_poly.to_crs(4326, inplace=True)\npoly.to_crs(4326, inplace=True)\nproximal_supers = super_gdf.sjoin(buffered_poly)\n\n\nfig, ax = plt.subplots()\npoly.plot(ax=ax, facecolor=\"red\", alpha=0.4)\nbuffered_poly.plot(ax=ax, facecolor=\"blue\", alpha=0.2)\nproximal_supers.plot(ax=ax, color=\"blue\", markersize=3)\nctx.add_basemap(\n    ax,\n    crs=proximal_supers.crs.to_string(), source=ctx.providers.CartoDB.Voyager\n)\nplt.title(f\"{len(proximal_supers)} Supermarkets Within 5 km Buffered Cardiff LAD extent\")\nplt.tight_layout()\nplt.savefig(\"outputs/cardiff-supermarkets/cardiff-supermarkets-5km-buffer.png\", dpi=400)"
  },
  {
    "objectID": "supermarket-accessibility-cardiff.html#by-output-area-population-weighted-centroid",
    "href": "supermarket-accessibility-cardiff.html#by-output-area-population-weighted-centroid",
    "title": "Analyse Supermaket Accessibility in Cardiff LAD",
    "section": "By Output Area Population-Weighted Centroid",
    "text": "By Output Area Population-Weighted Centroid\nOutput Areas (December 2021) PWC (V3)\n\nENDPOINT = \"https://services1.arcgis.com/ESMARspQHYMw9BZ9/arcgis/rest/services/Output_Areas_2021_PWC_V3/FeatureServer/0/query\"\nPARAMS[\"where\"] = \"OA21CD like 'W%'\"\nPARAMS[\"resultOffset\"] = 0\nPARAMS[\"outSR\"] = 4326\n\n\ndef get_ons_geo_paginated(endpoint:str, params:dict) -&gt; gpd.GeoDataFrame:\n    content, gdf = get_ons_geo_data(ENDPOINT, PARAMS)\n    more_pages = content[\"properties\"][\"exceededTransferLimit\"]\n    offset = len(gdf) # number of records to offset by\n    all_gdfs = gdf # append gdfs here\n    while more_pages:\n        params[\"resultOffset\"] += offset # increment the records\n        content, gdf = get_ons_geo_data(endpoint, params)\n        all_gdfs = pd.concat([all_gdfs, gdf])\n        try:\n            more_pages = content[\"properties\"][\"exceededTransferLimit\"]\n        except KeyError:\n            # rather than exceededTransferLimit = False, it disappears...\n            more_pages = False\n    all_gdfs = all_gdfs.reset_index(drop=True)\n    return all_gdfs\n\n\n# PARAMS[\"returnCountOnly\"] = True\n# 10275 Welsh centroids\ncentroids = get_ons_geo_paginated(ENDPOINT, PARAMS)\nlen(centroids)\n\n10275\n\n\n\ncardiff_centroids = centroids.sjoin(poly)\nfig, ax = plt.subplots()\npoly.plot(ax=ax, facecolor=\"red\", alpha=0.4)\nbuffered_poly.plot(ax=ax, facecolor=\"blue\", alpha=0.2)\nproximal_supers.plot(ax=ax, color=\"blue\", markersize=3)\nctx.add_basemap(\n    ax,\n    crs=proximal_supers.crs.to_string(), source=ctx.providers.CartoDB.Voyager\n)\nplt.title(f\"{len(cardiff_centroids)} Centroids Within Cardiff LAD extent\")\ncardiff_centroids.plot(ax=ax, color=\"green\", markersize=3, alpha=0.2)\nplt.tight_layout()\nplt.savefig(\"outputs/cardiff-supermarkets/cardiff-centroids-supermarkets-5km-buffer.png\", dpi=400)\n\n\n\n\n\n\n\n\n\n# get osm data\nosm_pth = here(\"data/external/osm/wales-latest.osm.pbf\")\nif not os.path.exists(osm_pth):\n  subprocess.run(\n      [\n        \"curl\",\n        \"https://download.geofabrik.de/europe/united-kingdom/wales-latest.osm.pbf\",\n        \"-o\",\n        osm_pth,])\n\nHere is where the Java dependency kicks in…\n\ntransport_network = r5py.TransportNetwork(osm_pth)\n# adjust all centroids to transport network\ncardiff_centroids[\"snapped_geometry\"] = transport_network.snap_to_network(\n    cardiff_centroids[\"geometry\"],\n    radius=100,\n    street_mode=r5py.TransportMode.WALK,\n)\n\n\n# snap distance summaries\n# reverse the lonlat to latlon\ncardiff_centroids[\"snap_dist_m\"] = cardiff_centroids.apply(\n    lambda row:haversine(\n        (row[\"geometry\"].y, row[\"geometry\"].x),\n        (row[\"snapped_geometry\"].y, row[\"snapped_geometry\"].x),\n        unit=Unit.METERS), axis=1)\n\ncardiff_centroids[\"snap_dist_m\"].plot.hist(\n    bins=50,\n    title=\"Distribution of coordinate snap distance in point plane (m)\"\n    )\nplt.show()\n\n\n\n\n\n\n\n\n\nlargest_snaps = cardiff_centroids.copy(deep=True)\n# retrieve the top n rows where coordinates adjusted by the greatest dist.\nn = 20\nlargest_snaps = largest_snaps.sort_values(\n    by=\"snap_dist_m\", ascending=False).head(n)\n# create the LineString geometry\nlargest_snaps[\"lines\"] = largest_snaps.apply(\n    lambda row: LineString([row[\"geometry\"], row[\"snapped_geometry\"]]),\n    axis=1\n)\nz_start = 11\n# original geometry layer\nimap = largest_snaps.explore(\n    marker_type=\"marker\",\n    marker_kwds={\n        \"icon\": folium.map.Icon(color=\"red\", icon=\"ban\", prefix=\"fa\"),\n    },\n    map_kwds={\n        \"center\": {\"lat\": 51.478, \"lng\": -3.165}\n    },\n    zoom_start=z_start,\n)\n# snapped geometry layer\nimap = largest_snaps.set_geometry(\"snapped_geometry\").explore(\n    m=imap,\n    marker_type=\"marker\",\n    marker_kwds={\n        \"icon\": folium.map.Icon(color=\"green\", icon=\"person-walking\", prefix=\"fa\"),\n    }\n)\n# line geometry layer\nimap = largest_snaps.set_geometry(\"lines\").explore(\n    m=imap,\n    zoom_start=z_start\n)\nimap\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n# drop the original centroids in favour of snapped geoms\ncardiff_centroids.drop(\n    columns=[\"geometry\", \"snap_dist_m\"], axis=1, inplace=True)\ncardiff_centroids.rename(columns={\n    \"snapped_geometry\": \"geometry\",\n    \"OA21CD\": \"id\",\n    }, inplace=True)\ncardiff_centroids.set_geometry(\"geometry\", inplace=True)\n\n\ndept_time = datetime.now().replace(hour=8, minute=0, second=0, microsecond=0)\n\ntravel_time_matrix = r5py.TravelTimeMatrixComputer(\n    transport_network,\n    origins=cardiff_centroids,\n    destinations=proximal_supers,\n    transport_modes=[r5py.TransportMode.WALK, r5py.TransportMode.CAR],\n    departure=dept_time,\n    departure_time_window=timedelta(minutes=60), # every minute until 9am\n    snap_to_network=False,\n    max_time=timedelta(minutes=60),\n    speed_walking = 4.8, # default is 3.6km/h\n\n).compute_travel_times()\n\ntravel_time_matrix.dropna().head()\n\n\n\n\n\n\n\n\n\nfrom_id\nto_id\ntravel_time\n\n\n\n\n0\nW00010120\n86\n9\n\n\n1\nW00010120\n273\n30\n\n\n2\nW00010120\n455\n16\n\n\n3\nW00010120\n456\n12\n\n\n4\nW00010120\n643\n30\n\n\n\n\n\n\n\n\n\nEngineer Travel Time Matrix\nCalculate median travel time across each supermarket. This gives us a median travel time from all centroids to all reachable supermarkets. Also need to merge to geometries to add spatial context. Going with 2021 boundaries generalised to 20m resolution as just for mapping a centroid value.\nOther features of interest may be:\n\nnumber of reachable supermarkets\nan ‘effective population served within 1 hour by car and by foot’.\nan accessibility statistic such as the ratio of reachable / proximal supermarkets. eg the number of supermarkets you can reach through the transport network as a proportion of the number within a crow’s flight radius.\n\n\nmed_tts = travel_time_matrix.drop(\"to_id\", axis=1).groupby(\"from_id\").median()\nENDPOINT = \"https://services1.arcgis.com/ESMARspQHYMw9BZ9/arcgis/rest/services/Output_Areas_2021_EW_BGC_V2/FeatureServer/0/query\"\nPARAMS[\"where\"] = \"OA21CD like 'W%'\"\nPARAMS[\"resultOffset\"] = 0\n\noa_polys = get_ons_geo_paginated(ENDPOINT, PARAMS)\nlen(oa_polys)\n\n10275\n\n\n\nmedian_tt_oa = med_tts.join(oa_polys.set_index(\"OA21CD\"))\nmedian_tt_oa = gpd.GeoDataFrame(median_tt_oa, crs=4326)\nmedian_tt_oa.head()\n\n\n\n\n\n\n\n\n\ntravel_time\ngeometry\nFID\nLSOA21CD\nLSOA21NM\nLSOA21NMW\nBNG_E\nBNG_N\nLAT\nLONG\nShape__Area\nShape__Length\nGlobalID\n\n\nfrom_id\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nW00008779\n12.5\nPOLYGON ((-3.15371 51.48625, -3.15409 51.48610...\n187079\nW01001694\nCardiff 036A\nCaerdydd 036A\n319717\n177053\n51.48670\n-3.15765\n37192.300659\n1323.933139\n22955f09-cd77-4133-b0c6-5d3d54a1564d\n\n\nW00008780\n12.0\nPOLYGON ((-3.15290 51.48853, -3.15203 51.48723...\n187080\nW01001697\nCardiff 036D\nCaerdydd 036D\n320018\n177178\n51.48787\n-3.15334\n20110.197174\n656.083765\nede6239d-fa9e-4fa2-95e4-d2609951f8dd\n\n\nW00008781\n12.0\nPOLYGON ((-3.15856 51.48645, -3.15806 51.48628...\n187081\nW01001694\nCardiff 036A\nCaerdydd 036A\n319566\n177006\n51.48626\n-3.15981\n42158.049187\n1093.054113\na45f08c9-683b-41fa-aebe-8c401cec73d8\n\n\nW00008782\n12.0\nPOLYGON ((-3.15490 51.48587, -3.15718 51.48494...\n187082\nW01001694\nCardiff 036A\nCaerdydd 036A\n319789\n176962\n51.48589\n-3.15659\n25546.097813\n655.481197\n0293396c-8ba5-4782-bf24-216461db1709\n\n\nW00008784\n13.0\nPOLYGON ((-3.15371 51.48625, -3.15447 51.48498...\n187083\nW01001694\nCardiff 036A\nCaerdydd 036A\n319925\n176862\n51.48502\n-3.15461\n34684.802540\n1455.580623\n888a5b61-4a7b-466d-ae54-fc9ff0685663\n\n\n\n\n\n\n\n\n\nimap = median_tt_oa.explore(\"travel_time\", cmap=\"viridis_r\", tiles=\"CartoDB positron\")\nimap = proximal_supers.explore(\n    m=imap,\n    marker_type=\"marker\",\n    marker_kwds={\n        \"icon\": folium.map.Icon(color=\"red\", icon=\"cart-shopping\", prefix=\"fa\"),\n    }\n)\nimap.save(\"outputs/cardiff-supermarkets/median_tt_to_supermarkets_5km_buffer.html\")\nimap\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nThis is one option for calculation of origins. Population-weighted centroids are ok, but I would advise taking a gridded approach, using Global Human Settlement Layer or equivalent. Finer spatial resolution, down to 10m grids if you really wanted that. There are some caveats with this data that I can point out if helpful."
  },
  {
    "objectID": "gp-surgeries-wolthamstow.html",
    "href": "gp-surgeries-wolthamstow.html",
    "title": "Analyse GP Surgery Accessibility in Walthamstow",
    "section": "",
    "text": "A brief summary of notebook:\n\nTravel times from Output Area population-weighted centroids to GP surgeries in Walthamstow.\nTransport modality is by foot and by private car.\nSurgeries are geolocated from postcodes using open street map’s Nominatim API. This would not scale well so other location data sources should be explored.\nScaling out to other areas hinges on the ability to provide location data for the services of interest.\nIncluding bus & rail modes is possible and subject to the peculiarities of GTFS data within the area of interest. Modelling bus & rail for other areas of UK would be trivial.\n\n\n\nClick to show code\nfrom datetime import datetime, timedelta\nimport glob\nimport os\nfrom pathlib import Path\nimport subprocess\nfrom time import sleep\nimport toml\n\nimport contextily as ctx\nimport folium\nimport geopandas as gpd\nfrom geopy.geocoders import Nominatim\nfrom geopy.exc import GeocoderUnavailable\nfrom geopy import point\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom pyprojroot import here\nimport r5py\nimport requests\nfrom shapely import geometry\n\nfrom transport_performance.osm.osm_utils import filter_osm\n\nfrom travel_time_experiments.ingest_ons_geo import (\n    get_ons_geo_data, get_ons_geo_paginated\n    )\nfrom travel_time_experiments.munge_gpd import add_linestring_col\nfrom travel_time_experiments.viz_gpd import viz_revised_coordinates\n\n# get private user agent\nUSER_AGENT = toml.load(here(\".secrets.toml\"))[\"nominatim\"][\"USER_AGENT\"]"
  },
  {
    "objectID": "gp-surgeries-wolthamstow.html#introduction",
    "href": "gp-surgeries-wolthamstow.html#introduction",
    "title": "Analyse GP Surgery Accessibility in Walthamstow",
    "section": "",
    "text": "A brief summary of notebook:\n\nTravel times from Output Area population-weighted centroids to GP surgeries in Walthamstow.\nTransport modality is by foot and by private car.\nSurgeries are geolocated from postcodes using open street map’s Nominatim API. This would not scale well so other location data sources should be explored.\nScaling out to other areas hinges on the ability to provide location data for the services of interest.\nIncluding bus & rail modes is possible and subject to the peculiarities of GTFS data within the area of interest. Modelling bus & rail for other areas of UK would be trivial.\n\n\n\nClick to show code\nfrom datetime import datetime, timedelta\nimport glob\nimport os\nfrom pathlib import Path\nimport subprocess\nfrom time import sleep\nimport toml\n\nimport contextily as ctx\nimport folium\nimport geopandas as gpd\nfrom geopy.geocoders import Nominatim\nfrom geopy.exc import GeocoderUnavailable\nfrom geopy import point\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom pyprojroot import here\nimport r5py\nimport requests\nfrom shapely import geometry\n\nfrom transport_performance.osm.osm_utils import filter_osm\n\nfrom travel_time_experiments.ingest_ons_geo import (\n    get_ons_geo_data, get_ons_geo_paginated\n    )\nfrom travel_time_experiments.munge_gpd import add_linestring_col\nfrom travel_time_experiments.viz_gpd import viz_revised_coordinates\n\n# get private user agent\nUSER_AGENT = toml.load(here(\".secrets.toml\"))[\"nominatim\"][\"USER_AGENT\"]"
  },
  {
    "objectID": "gp-surgeries-wolthamstow.html#ingest-data",
    "href": "gp-surgeries-wolthamstow.html#ingest-data",
    "title": "Analyse GP Surgery Accessibility in Walthamstow",
    "section": "Ingest Data",
    "text": "Ingest Data\nIngest London Open Street Map.\nLondon OSM doesn’t include Loughton & Cheshunt. To avoid edge effects, ingest England OSM latest & filter to custom bounding box.\n\n\nClick to show code\nosm_pth = here(\"data/external/osm/england-latest-osm.pbf\")\nif not os.path.exists(osm_pth):\n    subprocess.run(\n        [\n            \"curl\",\n            \"https://download.geofabrik.de/europe/united-kingdom/england-latest.osm.pbf\",\n            \"-o\",\n            osm_pth\n            ])\n# Clip London OSM to custom BBOX\nfiltered_osm_pth = here(\"data/external/osm/walthamstow-aoi-osm.pbf\")\nBBOX = [-0.368022,51.432659,0.296356,51.765395]\nif not os.path.exists(filtered_osm_pth):\n    filter_osm(\n        pbf_pth=osm_pth, out_pth=filtered_osm_pth, bbox=BBOX, tag_filter=False)\n\n\nIngest GP Addresses.\nFrom NHS Service Search , surgeries within 50 miles serving Hoe Street, Wolthamstow. Postcodes provided and will need to be geocoded. Investigate whether coordinates are available in NHS developer portal, registration required.\n\n\nClick to show code\nsurg_pth = here(\"data/external/features/nhs-surgeries-E17-3AX.csv\")\nif not os.path.exists(surg_pth):\n    subprocess.run([\n        \"curl\",\n        \"https://www.nhs.uk/service-search/other-services/GP/E17-3AX/Export/4/-0.0193444043397903/51.5837821960449/4/0?distance=50&ResultsOnPageValue=10&isNational=0&totalItems=2845&currentPage=1\",\n        \"-o\",\n        surg_pth\n    ])\nsurgeries = pd.read_csv(surg_pth)\nsurgeries = surgeries.loc[:, [\"Organisation Name\", \"PostCode\"]]\nsurgeries[\"id\"] = list(range(0, len(surgeries)))\n\n\nGeolocate GP Surgeries from address.\n\n\nClick to show code\ndef get_surgery_locs_nominatim(\n    df: pd.DataFrame, out_pth: Path, sleep_s:float=2.0, user: str = USER_AGENT\n    ) -&gt; None:\n    \"\"\"Use orgnm and then postcode to attempt geolocating surgeries. \n    \n    Uses Nominatim. Writes to file if error encountered. \n    \"\"\"\n    tmp_df = df.copy(deep=True)\n    # Instantiate a new Nominatim client\n    app = Nominatim(\n        user_agent=\"\")\n    tmp_df[\"lat\"] = 0.0\n    tmp_df[\"lon\"] = 0.0\n    tmp_df[\"geocode_type\"] = \"None\"\n    geocode_type = []\n    for i, row in tmp_df.iterrows():\n        loc = {\"lon\": 0.0, \"lat\": 0.0}\n        geo_type = \"None\"\n        try:\n            loc = app.geocode(\n                query=row[\"Organisation Name\"],\n                country_codes=\"gb\",\n                viewbox=[\n                    point.Point(51.375, -0.509), point.Point(51.868, 0.530)],\n                bounded=True)\n            print(\"Geocode by Org Name success\")\n            sleep(sleep_s)\n            geo_type = \"from_nm\"\n            if not loc:\n                # case where name did not return a location\n                loc = app.geocode(\n                    query=row[\"PostCode\"],\n                    country_codes=\"gb\",\n                    viewbox=[\n                        point.Point(51.375, -0.509), point.Point(51.868, 0.530)\n                        ],\n                    bounded=True)\n                print(\"Geocode by Postcode success\")\n                sleep(sleep_s)\n                geo_type = \"from_pcd\"\n        except GeocoderUnavailable:\n            # nominatim is down\n            print(f\"Breaking on {row['Organisation Name']}\")\n            break\n        finally:\n            # update the geometry column\n            if loc:\n                loc = loc.raw\n                tmp_df.loc[i, [\"lat\"]] = loc[\"lat\"]\n                tmp_df.loc[i, [\"lon\"]] = loc[\"lon\"]\n                tmp_df.loc[i, [\"geocode_type\"]] = geo_type\n            else:\n                break\n    tmp_df.to_csv(out_pth)\n    return tmp_df\n# execute once only as hammers the nominatim service\ngeocoded_surgeries_pth = here(\n    \"data/external/features/geocoded-london-surgeries.csv\")\nif not os.path.exists(geocoded_surgeries_pth):\n    get_surgery_locs_nominatim(df=surgeries, out_pth=cache_pth, sleep_s=2.0)\n\n\nPresent the geocoded surgeries.\n\n\nClick to show code\ngeocd_pth = here(\"data/external/features/\").glob(\"geocode-surgeries-*\")\ngeocd_surgeries = pd.read_csv(list(geocd_pth)[0], index_col=0)\ngeocd_surgeries = geocd_surgeries.dropna()\ngeocd_surgeries = gpd.GeoDataFrame(\n    geocd_surgeries,\n    geometry=gpd.points_from_xy(\n        geocd_surgeries[\"lon\"], geocd_surgeries[\"lat\"]), crs=4326)\ngeocd_surgeries.drop([\"lat\", \"lon\"], axis=1, inplace=True)\ngeocd_surgeries.explore()\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nNote that the accuracy of surgery location varies dependent upon whether the surgeries were geolocated from the organisation name or the postcode. Most are from postcode. Accuracy of these points will depend on size of postcode.\n\n\nClick to show code\ncode_stats = geocd_surgeries[\"geocode_type\"].describe()\nprint(\n    f\"{round((code_stats.freq / len(geocd_surgeries)) * 100, 1)} % of \"\n    f\"{len(geocd_surgeries)} surgeries were geocoded by postcode.\")\n\n\n57.4 % of 535 surgeries were geocoded by postcode.\n\n\nIngest Population-Weighted Centroids.\n\n\nClick to show code\nENDPOINT = \"https://services1.arcgis.com/ESMARspQHYMw9BZ9/arcgis/rest/services/Output_Areas_2021_PWC_V3/FeatureServer/0/query\"\nPARAMS = {\n    \"where\": \"OA21CD like 'E%'\",\n    \"f\": \"geoJSON\", \n    \"outFields\": \"*\",\n    \"outSR\": 4326,\n    \"returnCountOnly\": True,\n}\nresp = requests.get(ENDPOINT, PARAMS)\ncont = resp.json()\nn_centroids = cont['properties']['count']\nprint(\n    f\"There are {n_centroids:,} OA Centroids with the specified OA21CD pattern\"\n    )\n\n\nThere are 178,605 OA Centroids with the specified OA21CD pattern\n\n\n\n\nClick to show code\nPARAMS[\"returnCountOnly\"] = False\nPARAMS[\"resultOffset\"] = 0\ncentroids_pth = here(\"data/external/ons-geo/oa-centroids-2021.parquet\")\nif not os.path.exists(centroids_pth):\n    centroids = get_ons_geo_paginated(ENDPOINT, PARAMS)\nelse:\n    centroids = gpd.read_parquet(centroids_pth)\nprint(f\"All centroids ingested? {len(centroids) == n_centroids}\")\n\n\nAll centroids ingested? True\n\n\nIngest Wolthamstow LAD boundary\nUse LAD21 to match centroid release, though 23 is available. LADCD for Wolthamstow is E09000031.\n\n\nClick to show code\nENDPOINT = \"https://services1.arcgis.com/ESMARspQHYMw9BZ9/arcgis/rest/services/LAD_Dec_2021_GB_BFC_2022/FeatureServer/0/query\"\nPARAMS[\"where\"] = \"LAD21CD = 'E09000031'\"\ndel PARAMS[\"resultOffset\"]\nPARAMS[\"outSR\"] = 27700 # get in BNG as will need to buffer\n_, boundary = get_ons_geo_data(ENDPOINT, PARAMS)\nboundary.explore()\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "gp-surgeries-wolthamstow.html#engineering-the-data",
    "href": "gp-surgeries-wolthamstow.html#engineering-the-data",
    "title": "Analyse GP Surgery Accessibility in Walthamstow",
    "section": "Engineering the Data",
    "text": "Engineering the Data\nBuffer the LAD boundary to avoid edge effects - people may prefer surgeries in the adjacent local authority. Buffer by 5km, pretty arbitrary rule of thumb that can be adjusted to suit.\n\n\nClick to show code\nbuffered_bound = gpd.GeoDataFrame({\"geometry\": boundary.buffer(5000)})\nimap = boundary.explore(\n    map_kwds={\n        \"center\": {\"lat\": 51.603, \"lng\": -0.018}\n    },\n    zoom_start=10)\nimap = buffered_bound.explore(\n    m=imap,\n    style_kwds=dict(\n        color=\"purple\", weight=1, fillOpacity=0.3\n        ))\nimap\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nUse the centroids within the LAD boundary (blue). Use the GP surgeries within the 5km buffer (purple). Clip the points to Polygon extent.\n\n\nClick to show code\n# clip centroids to LAD boundary\nboundary = boundary.to_crs(4326)\nwalth_centroids = centroids.sjoin(boundary)\n# clip surgeries to buffer\nbuffered_bound = buffered_bound.to_crs(4326)\nproximal_gps = geocd_surgeries.sjoin(buffered_bound)\nimap = walth_centroids.explore(map_kwds={\n        \"center\": {\"lat\": 51.603, \"lng\": -0.018}\n    },\n    zoom_start=11.5, color=\"navy\")\nimap = proximal_gps.explore(\n    m=imap,\n    marker_type=\"marker\",\n    marker_kwds={\n        \"icon\": folium.map.Icon(\n            color=\"green\", icon=\"briefcase-medical\", prefix=\"fa\")\n    }\n)\nimap\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nThese are the journey origins (navy) and destinations (green)."
  },
  {
    "objectID": "gp-surgeries-wolthamstow.html#adjust-point-locations",
    "href": "gp-surgeries-wolthamstow.html#adjust-point-locations",
    "title": "Analyse GP Surgery Accessibility in Walthamstow",
    "section": "Adjust Point Locations",
    "text": "Adjust Point Locations\nAs many of the points will not be situated in routable locations, it can be beneficial to use the transport network to ‘snap’ the locations to the nearest feature of the network. This will often be the nearest node, but could also be configured as the nearest junction or bus stop.\n\n\nClick to show code\ntn = r5py.TransportNetwork(filtered_osm_pth)\nwalth_centroids[\"snapped_geometry\"] = tn.snap_to_network(\n    walth_centroids[\"geometry\"],\n    radius=75,\n    street_mode=r5py.TransportMode.WALK,\n)\nwalth_centroids = add_linestring_col(walth_centroids)\n# snap surgeries\nproximal_gps[\"snapped_geometry\"] = tn.snap_to_network(\n    proximal_gps[\"geometry\"],\n    radius=115,\n    street_mode=r5py.TransportMode.WALK,\n)\nproximal_gps = add_linestring_col(proximal_gps)\nproximal_gps[\"snap_dist_m\"].describe()\n\n\ncount    291.000000\nmean      16.186958\nstd        9.245808\nmin        0.000000\n25%       11.045884\n50%       14.546274\n75%       19.569081\nmax      103.341968\nName: snap_dist_m, dtype: float64\n\n\n75 % of the surgeries were revised within 20 metres.\n\n\nClick to show code\nproximal_gps[\"snap_dist_m\"].plot.hist(\n    bins=20, title=\"Distribution of Surgery Snap Distance in Metres\")\n\n\n\n\n\n\n\n\n\nVisualise the 10 surgery locations that were snapped farthest.\n\n\nClick to show code\n# visualise snapped geometry\nviz_revised_coordinates(proximal_gps.sort_values(\n    by=[\"snap_dist_m\"], ascending=[False]).head(10))\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nNote that there are some issues with the data. There are entries that share the same postcode that appear to be duplicate entries, these are overplotted on the maps but can be revealed with a little random noise.\nIt is also apparent that the quality of geocoding is variable. In the worst case, Nightingale House Surgery has been geocoded from postcode at a local school on Nightingale Road, some 600 metres away. Visual inspection of point samples confirm that this is the exception rather than the rule, but a cut of the geolytix surgery location data or equivalent would be best.\n\n\nClick to show code\noa_polys_pth = here(\"data/external/ons-geo/oa-polys-2021-BFC.parquet\")\nif not os.path.exists(oa_polys_pth):\n    ENDPOINT = \"https://services1.arcgis.com/ESMARspQHYMw9BZ9/arcgis/rest/services/Output_Areas_2021_EW_BFC_V8/FeatureServer/0/query\"\n    PARAMS[\"where\"] = \"OA21CD LIKE 'E%'\"\n    PARAMS[\"resultOffset\"] = 0\n    PARAMS[\"outSR\"] = 4326\n    oa_polys = get_ons_geo_paginated(ENDPOINT, PARAMS)\n    oa_polys.to_parquet(oa_polys_pth)\nelse:\n    oa_polys = gpd.read_parquet(oa_polys_pth)\n\nwalth_polys = oa_polys.set_index(\"OA21CD\").join(\n    walth_centroids.set_index(\"OA21CD\"),\n    how=\"right\", lsuffix=\"_l\", rsuffix=\"_r\")\nwalth_polys.set_geometry(\"geometry_l\", inplace=True)\nwalth_centroids[\"snap_dist_m\"].describe()\n\n\ncount    771.000000\nmean      16.688795\nstd       11.664236\nmin        0.017786\n25%        7.375896\n50%       15.289275\n75%       23.811737\nmax       73.991204\nName: snap_dist_m, dtype: float64\n\n\nMost of the centroids have been adjusted by less than 25 metres. Though there is at least one case snapped to over 70 metres.\n\n\nClick to show code\nwalth_centroids[\"snap_dist_m\"].plot.hist(\n    bins=20, title=\"Distribution of Centroid Snap Distance in Metres\")\n\n\n\n\n\n\n\n\n\nIt is likely that these snapped centroids now fall outside of the output area polygon they were intended to represent. Inspect the 10 largest revisions, check that they are within the bounds of their output area polygon.\n\n\nClick to show code\nimap = viz_revised_coordinates(\n    walth_centroids[\n        [\"snap_dist_m\", \"geometry\", \"OA21CD\", \"snapped_geometry\", \"lines\"]\n        ].sort_values(\n            by=[\"snap_dist_m\"], ascending=[False]).head(10), zoom=11.5)\nimap = walth_polys.reset_index()[[\"OA21CD\", \"geometry_l\"]].explore(\n    m=imap, style_kwds=dict(color=\"black\", weight=1, fillOpacity=0.1)\n    )\nimap\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nAs can be seen from the map, some points now do fall outside of the polygon they are intended to represent. We can account for this adjustment by adding an average walking time penalty to computed travel times."
  },
  {
    "objectID": "gp-surgeries-wolthamstow.html#calculate-travel-times",
    "href": "gp-surgeries-wolthamstow.html#calculate-travel-times",
    "title": "Analyse GP Surgery Accessibility in Walthamstow",
    "section": "Calculate Travel Times",
    "text": "Calculate Travel Times\nCompute travel times from centroids to proximal surgeries. Add a walking time penalty to account for the snap distance. Use walking speed of 4.8km/h, consistent with DfT travel time work. Calculate median travel times across surgeries.\n\n\nClick to show code\n# journey time with todays date\nwalth_centroids[\"id\"] = list(range(0, len(walth_centroids)))\nproximal_gps[\"id\"] = list(range(0, len(proximal_gps)))\ndept_time = datetime.now().replace(hour=8, minute=0, second=0, microsecond=0)\ntravel_time_matrix = r5py.TravelTimeMatrixComputer(\n    tn,\n    origins=walth_centroids,\n    destinations=proximal_gps,\n    transport_modes=[r5py.TransportMode.CAR, r5py.TransportMode.WALK],\n    departure=dept_time,\n    departure_time_window=timedelta(minutes=10), # Up to 08:10\n    snap_to_network=False,\n    max_time=timedelta(minutes=30), # 30 minute journey max \n).compute_travel_times()\nwalth_centroids[\"walk_penalty_mins\"] = walth_centroids[\"snap_dist_m\"] / 4800.0\\\n     * 60\nmed_tts_1 = travel_time_matrix.drop(\n    \"to_id\", axis=1).groupby(\"from_id\").median()\nmed_tts_1 = med_tts_1.join(walth_centroids.set_index(\"id\"))\nmed_tts_1[\"travel_time\"] = med_tts_1[\"travel_time\"] +\\\n     med_tts_1[\"walk_penalty_mins\"]\nmed_tts_1 = med_tts_1.set_index(\"OA21CD\").join(\n    walth_polys.set_index(\"OA21CD\"), lsuffix=\"_l\", rsuffix=\"_r\")\nmed_tts_1 = gpd.GeoDataFrame(med_tts_1, geometry=\"geometry_l\", crs=4326)\nmed_tts_1.head()\n\n\n\n\n\n\n\n\n\n\ntravel_time\nsnapped_geometry\nlines\nsnap_dist_m\nwalk_penalty_mins\ngeometry_l\n\n\nOA21CD\n\n\n\n\n\n\n\n\n\n\nE00185707\n19.212100\nPOINT (-0.03574 51.59128)\nLINESTRING (-0.03593 51.59139, -0.03574 51.59128)\n16.968013\n0.212100\nPOLYGON ((-0.03442 51.59101, -0.03441 51.59099...\n\n\nE00022297\n17.468352\nPOINT (-0.01472 51.56531)\nLINESTRING (-0.01526 51.56533, -0.01472 51.56531)\n37.468168\n0.468352\nPOLYGON ((-0.01530 51.56630, -0.01530 51.56629...\n\n\nE00021864\n17.229162\nPOINT (-0.01775 51.59748)\nLINESTRING (-0.01775 51.59764, -0.01775 51.59748)\n18.332924\n0.229162\nPOLYGON ((-0.01539 51.59756, -0.01545 51.59756...\n\n\nE00021924\n18.139814\nPOINT (-0.01814 51.62593)\nLINESTRING (-0.01807 51.62584, -0.01814 51.62593)\n11.185109\n0.139814\nPOLYGON ((-0.01537 51.62544, -0.01539 51.62547...\n\n\nE00022022\n15.319025\nPOINT (0.00281 51.59676)\nLINESTRING (0.00292 51.59698, 0.00281 51.59676)\n25.521986\n0.319025\nPOLYGON ((0.01289 51.59908, 0.01289 51.59907, ..."
  },
  {
    "objectID": "gp-surgeries-wolthamstow.html#present-results",
    "href": "gp-surgeries-wolthamstow.html#present-results",
    "title": "Analyse GP Surgery Accessibility in Walthamstow",
    "section": "Present Results",
    "text": "Present Results\n\nOption 1: Walthamstow 5km Buffer\nUse the selection widget on the right of the map to toggle layers on and off.\n\n\nClick to show code\nimap = med_tts_1.explore(\n    \"travel_time\",\n    cmap=\"viridis_r\",\n    tiles=\"CartoDB positron\",\n    zoom_start=12,\n    name=\"OA21 polygons\")\nimap = proximal_gps.set_geometry(\"snapped_geometry\").explore(\n    m = imap,\n    marker_type=\"marker\",\n    marker_kwds={\n        \"icon\": folium.map.Icon(\n            color=\"green\", icon=\"briefcase-medical\", prefix=\"fa\"),\n    }, name=\"destinations\"\n)\nimap = walth_centroids.set_geometry(\"snapped_geometry\").reset_index()[\n    [\"snapped_geometry\", \"OA21CD\"]].explore(\n    m=imap, color=\"navy\", opacity=0.2, name=\"origins\")\nimap.save(\n    \"outputs/walthamstow-surgeries/median_tt_to_surgeries_5km_buffer.html\")\nfolium.LayerControl().add_to(imap)\nimap\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nThis is an interesting situation - the high density of destinations in this locality could form the basis for a different treatment of proximal surgeries. The median travel time will be from one output area centroid to every GP on the map.\nIt may not be reasonable to consider all these options for each centroid. You could potentially draw a smaller buffer around each output area instead, and then calculate travel times to a smaller subset of proximal GPs.\n\n\nOption 2: Nearest 3 Surgeries\nThis option is used to model greater patient discrimination in surgery selection, due to the wealth of surgeries in the vicinity. In this scenario, patients select from the 3 surgeries with the smallest travel time only. Each centroid gets a median travel time across these 3 shortest journies only.\n\n\nClick to show code\nfast_3 = travel_time_matrix.sort_values(\n    [\"from_id\", \"travel_time\"], ascending=[True, True]\n    ).groupby(\n        \"from_id\").head(3).drop(\"to_id\", axis=1).groupby(\"from_id\").median()\n\nmed_tts_2 = fast_3.join(walth_centroids.set_index(\"id\"))\nmed_tts_2[\"travel_time\"] = med_tts_2[\"travel_time\"] + \\\n    med_tts_2[\"walk_penalty_mins\"]\nmed_tts_2 = med_tts_2.set_index(\n    \"OA21CD\"\n    ).join(walth_polys.set_index(\"OA21CD\"), lsuffix=\"_l\", rsuffix=\"_r\")\nmed_tts_2 = gpd.GeoDataFrame(med_tts_2, crs=4326, geometry=\"geometry_l\")\n\nimap = med_tts_2.explore(\n    \"travel_time\",\n    cmap=\"viridis_r\",\n    tiles=\"CartoDB positron\",\n    zoom_start=12,\n    name=\"OA21 polygons\")\nimap = proximal_gps.explore(\n    m = imap,\n    marker_type=\"marker\",\n    marker_kwds={\n        \"icon\": folium.map.Icon(\n            color=\"green\", icon=\"briefcase-medical\", prefix=\"fa\"),\n    }, name=\"destinations\"\n)\nimap = walth_centroids.reset_index().explore(\n    m=imap, color=\"navy\", opacity=0.2, name=\"origins\")\nimap.save(\n    \"outputs/walthamstow-surgeries//median_tt_to_surgeries_3_closest.html\")\nfolium.LayerControl().add_to(imap)\nimap\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\nOption 3: Output Area 1km buffer\nBuffer each output area by 1km and consider travel times to surgeries falling within those extents only. Find surgeries for each buffered output area. Check on surgeries within one output area.\n\n\nClick to show code\nwalth_polys[\"buffered_oas\"] = walth_polys.to_crs(\n    27700).buffer(1000)\nwalth_polys.set_geometry(\"buffered_oas\", inplace=True)\nwalth_polys[\"buffered_area_m\"] = walth_polys.area\nwalth_polys.to_crs(4326, inplace=True)\nfound_surgeries = gpd.GeoDataFrame()\nfor i, r in walth_polys.iterrows():\n    buff_gdf = gpd.GeoDataFrame(\n        {\"OA21CD\": r[\"OA21CD\"], \"geometry\": r[\"buffered_oas\"]},\n        index=[0], crs=4326)\n    out_df = buff_gdf.sjoin(geocd_surgeries, how=\"right\").dropna()\n    found_surgeries = gpd.GeoDataFrame(\n        pd.concat( [found_surgeries, out_df], ignore_index=True))\nwhich_oa = \"E00021834\"\nimap = found_surgeries.query(\"OA21CD == @which_oa\").explore(\n    marker_type=\"marker\",\n    zoom_start=11.5,\n    marker_kwds={\n        \"icon\": folium.map.Icon(\n            color=\"green\", icon=\"briefcase-medical\", prefix=\"fa\"),\n    })\n# show the buffered polygon\nimap = walth_polys.query(\"OA21CD == @which_oa\").explore(\n    m=imap, style_kwds={\"color\":\"black\", \"fillOpacity\":0.1})\n# show the original polygon\nimap = walth_polys.query(\"OA21CD == @which_oa\").set_geometry(\n    \"geometry_l\").explore(\n    m=imap, style_kwds={\"color\": \"purple\", \"fillOpacity\":0.5}\n)\n# get all surgeries that are not within the buffered OA\nimap = geocd_surgeries.loc[~geocd_surgeries[\"geometry\"].isin(\n    found_surgeries.query(\"OA21CD == @which_oa\")[\"geometry\"]), :].explore(\n    m=imap,\n    marker_type=\"marker\",\n    marker_kwds={\n        \"icon\": folium.map.Icon(\n            color=\"red\", icon=\"briefcase-medical\", prefix=\"fa\")\n    }\n)\nimap\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nCalculate Number of surgeries and travel times for each output area. With this option, the output areas are routed to unequal numbers of surgeries. Though every output area has at least one destination.\n\n\nClick to show code\nn_surgeries = found_surgeries.groupby(\n    \"OA21CD\")[\"Organisation Name\"].count().to_frame()\nwalth_centroids = walth_centroids.set_index(\n    \"OA21CD\").join(n_surgeries).reset_index()\nwalth_centroids.rename(\n    columns={\"Organisation Name\": \"n_surgeries\"}, inplace=True)\nopt_3_pth = here(\"data/interim/walthamstow-oa-1km-buffer-surgery-tts.parquet\")\nif not os.path.exists(opt_3_pth):\n    tt_matrix_2 = pd.DataFrame()\n    for i, row in walth_centroids.iterrows():\n        row_gdf = gpd.GeoDataFrame(\n            {\"id\": row[\"id\"], \"geometry\": row[\"snapped_geometry\"]},\n            index=[0], crs=4326)\n        tts = r5py.TravelTimeMatrixComputer(\n            tn,\n            origins=row_gdf,\n            destinations=found_surgeries.query(\"OA21CD == @row['OA21CD']\"),\n            transport_modes=[r5py.TransportMode.CAR, r5py.TransportMode.WALK],\n            departure=dept_time,\n            departure_time_window=timedelta(minutes=10), # Up to 08:10\n            snap_to_network=False,\n            max_time=timedelta(minutes=30), # 30 minute journey max \n        ).compute_travel_times()\n        tt_matrix_2 = pd.concat([tt_matrix_2, tts])\n    tt_matrix_2.to_parquet(opt_3_pth)\nelse:\n    tt_matrix_2 = pd.read_parquet(opt_3_pth)\n\nmed_tts_3 = tt_matrix_2.drop(\"to_id\", axis=1).groupby(\"from_id\").median()\nmed_tts_3 = med_tts_3.join(walth_centroids.set_index(\"id\"))\n# add the walk time penalty\nmed_tts_3[\"travel_time\"] = med_tts_3[\"travel_time\"] +\\\n     med_tts_3[\"walk_penalty_mins\"]\nmed_tts_3[\"n_surgeries\"].describe()\n\n\ncount    771.000000\nmean       5.041505\nstd        2.460776\nmin        1.000000\n25%        3.000000\n50%        5.000000\n75%        7.000000\nmax       12.000000\nName: n_surgeries, dtype: float64\n\n\nAs can be seen below, travel time does trend by the number of surgeries in scope of the buffered output areas. This scenario is distinct to options 1 and 2 in that respect.\n\n\nClick to show code\n# normalise n_surgeries, get areas from the polygons\nmed_tts_3 = walth_polys.loc[:, [\"OA21CD\", \"buffered_area_m\"]].set_index(\n    \"OA21CD\").join(med_tts_3.set_index(\"OA21CD\"))\nmed_tts_3[\"surgeries_per_km2\"] = med_tts_3[\"n_surgeries\"] / (\n    med_tts_3[\"buffered_area_m\"]/1_000_000)\nmed_tts_3.plot.scatter(\n    x=\"surgeries_per_km2\", y=\"travel_time\",\n    title=\"Median Travel Time by Surgeries per KM2\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nClick to show code\nmed_tts_3 = med_tts_3.join(\n    walth_polys.set_index(\"OA21CD\"), lsuffix=\"_l\", rsuffix=\"_r\")\nmed_tts_3 = gpd.GeoDataFrame(\n    med_tts_3[\n        [\n            \"geometry_l\",\n            \"travel_time\",\n            \"snap_dist_m\",\n            \"walk_penalty_mins\",\n            \"n_surgeries\",\n            \"surgeries_per_km2\"]\n            ], geometry=\"geometry_l\", crs=4326)\nimap = med_tts_3.explore(\n    \"travel_time\",\n    cmap=\"viridis_r\",\n    tiles=\"CartoDB positron\",\n    zoom_start=12,\n    name=\"OA21 polygons\")\nimap = proximal_gps.explore(\n    m = imap,\n    marker_type=\"marker\",\n    marker_kwds={\n        \"icon\": folium.map.Icon(\n            color=\"green\", icon=\"briefcase-medical\", prefix=\"fa\"),\n    }, name=\"destinations\"\n)\nimap = walth_centroids.reset_index().explore(\n    m=imap, color=\"navy\", opacity=0.2, name=\"origins\")\nfolium.LayerControl().add_to(imap)\nimap\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Travel Time Experiments",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nAnalyse GP Surgery Accessibility in Walthamstow\n\n\n\n\n\nLocations Provided by Open Street Map Data\n\n\n\n\n\nFeb 27, 2024\n\n\nRich Leyshon\n\n\n17 min\n\n\n\n\n\n\n\n\n\n\n\n\nAnalyse Supermaket Accessibility in Cardiff LAD\n\n\n\n\n\nDemonstrating a Method for Calculating Indiciative Travel Time Metrics\n\n\n\n\n\nFeb 20, 2024\n\n\nRich Leyshon\n\n\n6 min\n\n\n\n\n\n\nNo matching items"
  }
]